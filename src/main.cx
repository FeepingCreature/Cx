module main;

macro import cx.macros.listcomprehension;

import backend.base;
import backend.c;
import backend.llvm;
import backend.proxy;
import cx.array;
import cx.base;
import cx.expr;
import cx.hash;
import cx.linenr;
import cx.parser_base;
import cx.statements;
import cx.stuff;
import cx.types;
import helpers;

extern(C) int getpid();
extern(C) void cxruntime_file_write(string file, string content);
extern(C) void cxruntime_system(string command);
extern(C) void cxruntime_dlcall(string soname, string name, void* arg);
extern(C) bool cxruntime_waitpid(int pid);
extern(C) int cxruntime_execbg(string command, string[] arguments);

string removeExtension(string s) {
    string shortened = s;
    while (shortened.length > 0 && shortened[shortened.length - 1 .. shortened.length] != ".")
        shortened = shortened[0 .. shortened.length - 1];
    if (shortened.length) return shortened[0 .. shortened.length - 1]; else return s;
}

string removeSlashes(string s) {
    string result;
    for (int i = 0; i < s.length; i += 1) {
        if (s[i .. i + 1] == "/") result = result ~ "_";
        else result = result ~ s[i .. i + 1];
    }
    return result;
}

int find(string text, string match) {
    for (int i = 0; i <= text.length - match.length; i += 1)
        if (text[i .. i + match.length] == match) return i;
    return -1;
}

// pseudo brute force zip compression
// Hallo Wallo
// "Hallo Wallo" in ""? No.
// "Hallo Wall" in ""? No.
// ... "H" in ""? No.
// "allo Wallo" in "H"? No.
// ...
// "allo" in "Hallo W"? Yes.
// Hallo WB2-5
string compress(string symbol) {
    string result;
    for (size_t i = 0; i < symbol.length; i += 1) {
        bool found;
        for (size_t k = symbol.length; k > i; k -= 1) {
            string sample = symbol[i .. k];
            int pos = find(symbol[0 .. i], sample);
            if (pos != -1) {
                string replace = "B" ~ ltoa(pos) ~ "N" ~ ltoa(k - i);
                if (replace.length < sample.length)
                {
                    result ~= replace;
                    i += sample.length - 1;
                    found = true;
                    break;
                }
            }
        }
        if (!found) result ~= symbol[i];
    }
    return result;
}

string replace(string str, string match, string replace) {
    string result;
    size_t i = 0;
    while (i <= str.length - match.length) {
        if (str[i .. i + match.length] == match) {
            result ~= replace;
            i += match.length;
        } else {
            result ~= str[i];
            i += 1;
        }
    }
    result ~= str[i .. str.length];
    return result;
}

struct BackgroundCompilation
{
    string objFile;
    int pid;
}

BackgroundCompilation emitModule(CompilerBase compiler, Backend backend, Platform platform, Module module_,
    bool opt, bool m32, bool caching)
{
    auto backendModule = backend.createModule(platform);
    auto backendModuleLLVM = backendModule.instanceOf(LLVMBackendModule);
    auto backendModuleC = backendModule.instanceOf(CBackendModule);
    auto hash = new Hash;

    string join(string[] values, string joiner) {
        string ret;
        for (int i = 0; i < values.length; i += 1) {
            if (i) ret ~= joiner;
            ret ~= values[i];
        }
        return ret;
    }
    int build(string src, string obj) {
        string exec;
        string[] args;
        if (backendModuleLLVM) {
            if (opt) { exec = "sh"; args = [".obj/llvmBuildOpt.sh", src, obj]; }
            else { exec = "sh"; args = [".obj/llvmBuild.sh", src, obj]; }
            assert(!m32);
        } else {
            if (opt) { exec = "gcc"; args = ["-fpic", "-O3", src, "-o", obj]; }
            else { exec = "gcc"; args = ["-fpic", src, "-o", obj]; }
            if (m32) args ~= "-m32";
        }
        string cmd = exec ~ " " ~ join(args, " ");
        int pid = cxruntime_execbg(exec, args);
        print("$ " ~ cmd ~ " [&" ~ itoa(pid) ~ "]");
        return pid;
    }

    // TODO add compiler checksum (generation number?)
    if (backendModuleLLVM) hash.adds("LLVM");
    else hash.adds("gcc");
    if (m32) hash.adds("m32");
    if (opt) hash.adds("opt");

    auto symbols = module_.compile(compiler, platform);

    [symbol.hash(hash) for symbol in symbols];

    string objFile;
    if (backendModuleLLVM) {
        objFile = ".obj/" ~ hash.text() ~ ".bc";
    } else {
        objFile = ".obj/" ~ hash.text() ~ ".o";
    }

    if (caching && cxruntime_file_exists(objFile))
        return BackgroundCompilation(objFile, 0);

    auto generator = new Generator(platform, backendModule);
    module_.emit(generator, symbols);
    backendModule.done();

    int pid;
    if (backendModuleLLVM) {
        string srcFile = ".obj/" ~ compress(removeSlashes(module_.mangle())) ~ ".ll";
        {
            auto llText = backendModuleLLVM.output.text();
            cxruntime_file_write(srcFile, llText);
        }
        backendModuleLLVM.output.free();
        pid = build(srcFile, objFile);
    } else {
        assert(!!backendModuleC);
        string srcFile = ".obj/" ~ removeSlashes(module_.mangle()) ~ ".c";
        {
            auto csrc = backendModuleC.output.text();
            cxruntime_file_write(srcFile, csrc);
        }
        backendModuleC.output.free();
        pid = build(srcFile, objFile);
    }
    return BackgroundCompilation(objFile, pid);
}

class ParserHelperImpl : ParserHelper
{
    CompilerBase compiler;

    Backend backend;

    bool x86_32;

    bool caching;

    this(this.compiler, this.backend, this.x86_32, this.caching) { }

    // TODO why do we need 'config'?
    override void proxyCall(ASTModule astModule, string function_, MacroState macroState, ModuleParserConfig config)
    {
        print("# stageM");
        BackendType macroWordType;
        if (x86_32) macroWordType = new BackendIntType;
        else macroWordType = new BackendLongType;
        auto platform = new Platform(macroWordType);

        // throwaway compilation (TODO cache?)
        Module module_ = compileModule(astModule, this, config, compiler, platform, true);
        Module[] allModules;
        Module[] remainingModules = module_.newModules(allModules);
        allModules = remainingModules;

        string baseCmd;
        if (backend.instanceOf(LLVMBackend)) baseCmd = "clang -Wno-unused-command-line-argument -fpic";
        else if (backend.instanceOf(CBackend)) baseCmd = "gcc -fpic";
        else assert(false);
        if (x86_32) baseCmd ~= " -m32";

        auto libHash = new Hash;
        string objFiles;
        int[] pids;
        while (remainingModules.length > 0) {
            for (int i = 0; i < remainingModules.length; i += 1) {
                auto compilation = emitModule(compiler, backend, platform, remainingModules[i], false, x86_32, caching);
                objFiles ~= " " ~ compilation.objFile;
                if (compilation.pid != 0) pids ~= compilation.pid;
                libHash.adds(compilation.objFile);
            }
            remainingModules = module_.newModules(allModules);
            allModules ~= remainingModules;
        }

        for (int i = 0; i < pids.length; i += 1) {
            if (!cxruntime_waitpid(pids[i]))
                assert(false);
        }

        auto fun = module_.lookup(function_, null).instanceOf(Function);
        string name = fun.mangle();
        string soname;
        string cmd;
        if (backend.instanceOf(LLVMBackend)) {
            soname = ".obj/macro_" ~ name ~ "_" ~ libHash.text() ~ ".so";
            cmd = baseCmd ~ " -shared" ~ objFiles ~ " -o " ~ soname;
        }
        else if (backend.instanceOf(CBackend)) {
            soname = ".obj/macro_" ~ name ~ "_" ~ libHash.text() ~ ".so";
            string flags = " -shared -g src/runtime.c";
            if (platform.nativeWordType.instanceOf(BackendIntType)) flags ~= " -m32";
            cmd = baseCmd ~ flags ~ objFiles ~ " -o " ~ soname;
        }
        else assert(false);

        if (!caching || !cxruntime_file_exists(soname)) {
            print("$ " ~ cmd);
            cxruntime_system(cmd);
        }
        cxruntime_dlcall(soname, name, macroState);
    }
}

// "AST", lol. Package fresh off the commandline, dependencies not resolved yet.
// Needed because we can reference future packages.
struct ASTPackage
{
    string name;
    string path;
    string[] deps;
}

string slice(string* text, string marker)
{
    int pos = find(*text, marker);
    if (pos == -1) {
        string result = *text;
        *text = "";
        return result;
    }
    string result = (*text)[0 .. pos];
    *text = (*text)[pos + marker.length .. (*text).length];
    return result;
}

ASTPackage parsePackage(string arg)
{
    string name = slice(&arg, ":");
    assert(name.length > 0);
    string path = slice(&arg, ":");
    assert(path.length > 0);
    string[] deps;
    while (arg.length)
    {
        deps ~= slice(&arg, ",");
    }
    return ASTPackage(name, path, deps);
}

Package[] resolvePackages(ASTPackage[] astPackages)
{
    Package[] result = [new Package(pkg.name, pkg.path) for pkg in astPackages];
    for (int i = 0; i < astPackages.length; i += 1) {
        auto astPackage = astPackages[i];
        for (int j = 0; j < astPackage.deps.length; j += 1) {
            Package dep;
            for (int k = 0; k < result.length; k += 1) {
                if (result[k].name == astPackage.deps[j]) {
                    if (dep) print("Dependency '" ~ astPackage.deps[j] ~ "' of '" ~ astPackage.name ~ "' exists twice!");
                    assert(!dep);
                    dep = result[k];
                    break;
                }
            }
            if (!dep) {
                print("Missing package dependency: " ~ astPackage.deps[j]);
                assert(false);
            }
            result[i].addDependency(dep);
        }
    }
    return result;
}

class FixedTypeAlias : ASTType
{
    Type type;

    this(this.type) { }

    override Type compile(Context context) { return this.type; }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'FixedTypeAlias'!"); assert(false); }
}

class FixedExpressionAlias : ASTSymbol
{
    Symbol symbol;

    this(this.symbol) { }

    override Symbol compile(Context context) { return this.symbol; }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'FixedExpressionAlias'"); assert(false); }
}

// TODO this should be ASTNamedType
class ASTSizeT : ASTType
{
    this() { }

    override Type compile(Context context) {
        return nativeWordType(context.platform);
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTSizeT'!"); assert(false); }
}

class CompilerImpl : CompilerBase
{
    ASTModule[] defaultImports;

    this(this.defaultImports) { this.linenr = new LineNumberRegistry; }

    Module delegate(ASTModule) compile;

    // parser
    override ASTSymbol parseExpression(Parser parser, LexicalContext lexicalContext)
    {
        return .parseExpression(parser, lexicalContext);
    }

    override ASTSymbol parseExpressionLeaf(Parser parser, LexicalContext lexicalContext)
    {
        return .parseExpressionLeaf(parser, lexicalContext);
    }

    override ASTStatement parseStatement(Parser parser, LexicalContext lexicalContext)
    {
        return .parseStatement(parser, lexicalContext);
    }

    override ASTType parseType(Parser parser, LexicalContext lexicalContext)
    {
        return .parseType(parser, lexicalContext);
    }

    override ASTSymbol astBinaryOp(string op, ASTSymbol left, ASTSymbol right, ReLoc reloc)
    {
        return new ASTBinaryOp(op, left, right, Loc(linenr, reloc));
    }

    override ASTSymbol astIndex(ASTSymbol base, ASTSymbol index, ReLoc reloc)
    {
        return new ASTIndexAccess(base, index, Loc(linenr, reloc));
    }

    override ASTSymbol astMember(ASTSymbol base, string member, ReLoc reloc)
    {
        return new ASTMember(base, member, Loc(linenr, reloc));
    }

    override ASTSymbol astReference(ASTSymbol value, ReLoc reloc)
    {
        return new ASTReference(value, Loc(linenr, reloc));
    }

    override ASTSymbol astDereference(ASTSymbol value, ReLoc reloc)
    {
        return new ASTDereference(value, Loc(linenr, reloc));
    }

    override ASTSymbol astIntLiteral(int value, ReLoc reloc)
    {
        return new ASTIntLiteral(value, Loc(linenr, reloc));
    }

    override ASTSymbol astLongLiteral(long value, ReLoc reloc)
    {
        return new ASTLongLiteral(value, Loc(linenr, reloc));
    }

    override ASTSymbol astStringLiteral(string text, ReLoc reloc)
    {
        return new ASTStringLiteral(text, Loc(linenr, reloc));
    }

    override ASTSymbol astArrayLiteral(ASTSymbol[] values, ReLoc reloc)
    {
        auto elements = [ASTArrayLiteralElement(value, Loc(linenr, reloc)) for value in values];
        return new ASTArrayLiteral(elements);
    }

    override ASTSymbol astVoidLiteral(ReLoc reloc)
    {
        return new ASTVoidExpression(Loc(linenr, reloc));
    }

    override ASTSymbol astIdentifier(string name, ReLoc reloc)
    {
        return new ASTIdentifier(name, false, Loc(linenr, reloc));
    }

    override ASTSymbol astNegation(ASTSymbol value, ReLoc reloc)
    {
        return new ASTNegation(value, Loc(linenr, reloc));
    }

    override ASTSymbol astCall(ASTSymbol target, ASTSymbol[] args, ReLoc reloc)
    {
        return new ASTCall(target, args, Loc(linenr, reloc));
    }

    override ASTSymbol astNewExpression(ASTType type, ASTSymbol[] args, ReLoc reloc)
    {
        return new ASTNewExpression(type, args, Loc(linenr, reloc));
    }

    override ASTSymbol astDestroy(ASTSymbol target, ReLoc reloc)
    {
        return new ASTDestroy(target, Loc(linenr, reloc));
    }

    override ASTSymbol astCast(ASTType target, ASTSymbol value, ReLoc reloc)
    {
        return new ASTCastExpr(target, value, Loc(linenr, reloc));
    }

    override ASTStatement astExpressionStmt(ASTSymbol expr, ReLoc reloc)
    {
        return new ASTExprStatement(expr, Loc(linenr, reloc));
    }

    override ASTStatement astScope(ASTStatement[] statements, ReLoc reloc)
    {
        return new ASTScopeStatement(statements, Loc(linenr, reloc));
    }

    override ASTStatement astSequence(ASTStatement[] statements, ReLoc reloc)
    {
        return new ASTSequenceStatement(statements, Loc(linenr, reloc));
    }

    override ASTStatement astIf(ASTSymbol test, ASTStatement then, ASTStatement else_, ReLoc reloc)
    {
        return new ASTIfStatement(test, then, else_, Loc(linenr, reloc));
    }

    override ASTStatement astForLoop(
        ASTStatement init, ASTSymbol test, ASTStatement step, ASTStatement body_, ReLoc reloc)
    {
        return new ASTForLoop(init, test, step, body_, Loc(linenr, reloc));
    }

    override ASTStatement astAssign(ASTSymbol target, ASTSymbol source, ReLoc reloc)
    {
        return new ASTAssignStatement(target, source, Loc(linenr, reloc));
    }

    override ASTStatement astDeclareVar(string name, ASTSymbol initial, ReLoc reloc)
    {
        return new ASTVarDeclStatement(name, true, null, initial, Loc(linenr, reloc));
    }

    override ASTStatement astDeclareTypedVar(string name, ASTType type, ASTSymbol initial, ReLoc reloc)
    {
        return new ASTVarDeclStatement(name, false, type, initial, Loc(linenr, reloc));
    }

    override ASTStatement astReturn(ASTSymbol value, ReLoc reloc)
    {
        return new ASTReturnStatement(value, Loc(linenr, reloc));
    }

    override ASTType astArray(ASTType elementType, ReLoc reloc)
    {
        return new ASTArray(elementType, Loc(linenr, reloc));
    }

    override ASTType astNamedType(string name, ReLoc reloc)
    {
        return new ASTNamedType(name, Loc(linenr, reloc));
    }

    override ASTType astTypeOf(ASTSymbol value, ReLoc reloc)
    {
        return new ASTTypeof(value, Loc(linenr, reloc));
    }

    override ASTType astPointer(ASTType target, ReLoc reloc)
    {
        return new ASTPointer(target, Loc(linenr, reloc));
    }

    // expressions and statements
    override Expression implicitConvertTo(Expression from, Type to)
    {
        return .implicitConvertTo(from, to);
    }

    override Expression intLiteral(int value) { return new IntLiteral(value); }

    override Expression stringLiteral(string value) { return new StringLiteral(value); }

    override Expression call(FunctionDeclaration fun, Expression[] args, Loc loc)
    {
        return new Call(fun, args, loc);
    }

    override Expression binaryOp(string op, Context context, Expression left, Expression right, Loc loc)
    {
        if (op == "~")
        {
            return arrayCat(context, left, right, loc);
        }
        return new BinaryOp(op, left, right, loc);
    }

    override Expression binaryOp2(string op, Context context, Expression left, Expression right, Loc loc)
    {
        if (op == "~")
        {
            return arrayCat(context, left, right, loc);
        }
        return new BinaryOp(op, left, right, loc);
    }

    override Expression truthy(Expression value, Loc loc)
    {
        return .truthy(value, loc);
    }

    override Reference dereference(Expression value)
    {
        return new Dereference(value);
    }

    override Expression reference(Reference ref_)
    {
        return new ReferenceExpression(ref_);
    }

    override Expression pointerOffset(Expression pointer, Expression offset)
    {
        return new PointerOffset(pointer, offset);
    }

    override Statement assignStatement(Reference target, Expression value)
    {
        return new AssignStatement(target, value);
    }

    override Statement sequenceStatement(Statement[] stmts)
    {
        return new SequenceStatement(stmts);
    }

    override Statement ifStatement(Expression test, Statement then, Statement else_)
    {
        return new IfStatement(test, then, else_);
    }

    override Statement loopStatement(
        Context context, Statement initializer, Expression test, Statement body_, Statement step)
    {
        return new Loop(context.getLabel(), initializer, test, body_, step);
    }

    override Statement exprStatement(Expression test)
    {
        return new ExprStatement(test);
    }

    override Namespace exprAlias(Namespace parent, string name, Symbol value)
    {
        return new ExpressionAlias(parent, name, value);
    }

    override VariableDeclarationBase variableDeclaration(Namespace parent, string name, Type type)
    {
        return new VariableDeclaration(parent, name, type);
    }

    override Statement move(Context context, Reference target, Expression source)
    {
        return .move(context, target, source);
    }

    override Statement stmtWithTemporary(Expression value, Statement delegate(Expression) callback)
    {
        auto temp = new PairedTemporary(value.type(), value.temporary());
        auto start = new InitializeTemporaryStatement(temp, value);
        return new SequenceStatement([start, callback(temp)]);
    }

    override Expression exprWithTemporary(Expression value, Expression delegate(Expression) callback)
    {
        auto temp = new PairedTemporary(value.type(), value.temporary());
        auto start = new InitializeTemporaryStatement(temp, value);
        return new StatementExpression(start, callback(temp));
    }

    override Expression statementExpression(Statement statement, Expression expression)
    {
        return new StatementExpression(statement, expression);
    }

    void addDefaultImports(Module module_)
    {
        auto defaultMods = [compile(mod) for mod in this.defaultImports];
        [module_.addImport(mod) for mod in defaultMods];
    }

    override FunctionDeclaration createRuntimeFunction(
        Context context, string name, Type ret, Argument[] args, ASTStatement body_)
    {
        Loc loc; // bleh
        string path;
        // TODO in Function
        string mangledName = name;
        for (int i = 0; i < args.length; i += 1) {
            mangledName ~= "_" ~ args[i].type.mangle();
        }
        auto fun = new Function(loc, mangledName, ret, args, body_, context.macroState);
        auto rtMod = new Module(name, new Package("rt_" ~ mangledName, path), context.macroState, null);
        rtMod.add("free", new FunctionDeclaration(
            "free", new Void, [Argument(false, "", new Pointer(new Void))]));
        rtMod.add("print", new FunctionDeclaration(
            "print", new Void, [Argument(false, "", new Array(new Character))]));
        rtMod.add("ltoa", new FunctionDeclaration(
            "cxruntime_ltoa", new Array(new Character), [Argument(false, "", new Long)]));
        fun.parent = rtMod;
        string types;
        rtMod.add("__" ~ name, fun);
        addDefaultImports(rtMod);
        auto usingMod = findModule(context.namespace);
        usingMod.addImport(rtMod);
        return fun;
    }
}

void main(string[] args)
{
    print("# stage2");
    string output;
    string[] nextArgs;
    string[] linkerArgs;
    ASTPackage[] astPackages;
    bool dontLink;
    bool optimize;
    bool caching = true;
    bool x86_32; bool macro_x86_32;
    // auto backend = new ProxyBackend();
    Backend backend = new LLVMBackend();
    Backend macroBackend = backend;
    {
        string[] remArgs;
        for (size_t i = 0; i < args.length; i += 1) {
            string arg = args[i];
            string flag;
            if (arg.length >= 2) flag = arg[0 .. 2];

            // package: like includes, but scoped
            // -Pname:path[:dep1[,dep2]*]?
            if (flag == "-P") {
                astPackages ~= parsePackage(arg[2 .. arg.length]);
            } else if (flag == "-l") {
                linkerArgs ~= arg;
            } else if (flag == "-L") {
                linkerArgs ~= arg[2 .. arg.length];
            } else if (arg == "--") {
                nextArgs = args[i + 1 .. args.length];
                break;
            } else if (arg == "-o") {
                assert(i + 1 < args.length);
                output = args[i + 1];
                i += 1;
            } else if (arg == "-O") {
                optimize = true;
            } else if (arg == "-c") {
                dontLink = true;
            } else if (arg == "-x") {
                caching = false;
            } else if (arg == "-backend=c") {
                backend = new CBackend;
            } else if (arg == "-macro-backend=c") {
                macroBackend = new CBackend;
            } else if (arg == "-m32") {
                x86_32 = true;
            } else if (arg == "-macro-m32") {
                macro_x86_32 = true;
            } else {
                remArgs = remArgs ~ arg;
            }
        }
        args = remArgs;
    }
    Package[] packages = resolvePackages(astPackages);

    if (args.length != 1)
    {
        print("Usage: cx [-Pname:path[:dep1[,dep2]*]?]* FILE.cx");
        return;
    }
    if (!output.length) output = removeExtension(args[0]);

    cxruntime_system("mkdir -p .obj");
    createBuilderScripts();

    auto builtins = new ASTModule("", new Package("builtins", ""), new MacroState, null);
    BackendType nativeWordType;
    if (x86_32) nativeWordType = new BackendIntType;
    else nativeWordType = new BackendLongType;
    auto platform = new Platform(nativeWordType);

    builtins.addTypeAlias("string", new FixedTypeAlias(new Array(new Character)));
    builtins.addTypeAlias("bool", new FixedTypeAlias(new Integer));
    builtins.addTypeAlias("size_t", new ASTSizeT);
    builtins.addExprAlias("true", new FixedExpressionAlias(new IntLiteral(1)));
    builtins.addExprAlias("false", new FixedExpressionAlias(new IntLiteral(0)));
    builtins.addExprAlias("null", new FixedExpressionAlias(new NullExpr(new Pointer(new Void))));

    auto defaultImports = new ASTModule[](0) ~ builtins;
    auto compilerImpl = new CompilerImpl(defaultImports);
    auto astCache = new ASTModuleCache;
    auto cache = new ModuleCache;
    auto modParseConfig = new ModuleParserConfig(packages, defaultImports, astCache, cache);
    auto helper = new ParserHelperImpl(
        compilerImpl, macroBackend,
        macro_x86_32, caching);

    Module compile(ASTModule astMod) {
        return compileModule(astMod, helper, modParseConfig, compilerImpl, platform, true);
    }
    compilerImpl.compile = &compile;
    auto astToplevel = getModule(compilerImpl, args[0], null, false, helper, modParseConfig, Loc(null, ReLoc("", 0)));
    auto toplevel = compile(astToplevel);

    string baseFlags;
    if (optimize) {
        baseFlags ~= " -Ofast";
        if (backend.instanceOf(LLVMBackend))
            baseFlags ~= " -flto";
    }
    if (x86_32) baseFlags ~= " -m32";

    Module[] allModules;
    Module[] remainingModules = toplevel.newModules(allModules);
    allModules = remainingModules;

    string fileArgs;
    int[] pids;
    while (remainingModules.length > 0) {
        for (int i = 0; i < remainingModules.length; i += 1) {
            auto compilation = emitModule(compilerImpl, backend, platform, remainingModules[i],
                optimize, x86_32, caching);
            fileArgs ~= " " ~ compilation.objFile;
            if (compilation.pid != 0) pids ~= compilation.pid;
        }
        remainingModules = toplevel.newModules(allModules);
        allModules ~= remainingModules;
    }

    for (int i = 0; i < pids.length; i += 1) {
        if (!cxruntime_waitpid(pids[i]))
            assert(false);
    }

    if (dontLink) return;

    // int pid = getpid();
    // cxruntime_system("cat /proc/" ~ itoa(pid) ~ "/status");
    string flags = baseFlags ~ " -rdynamic";
    string linkerFlags = " -ldl";
    for (int i = 0; i < linkerArgs.length; i += 1) linkerFlags ~= " " ~ linkerArgs[i];
    string compiler = "clang -Wno-unused-command-line-argument -fpic";
    if (backend.instanceOf(CBackend)) compiler = "gcc";
    string cmd = compiler ~ flags ~ fileArgs ~ " src/runtime.c -o " ~ output ~ linkerFlags;
    print("$ " ~ cmd);
    cxruntime_system(cmd);
}

void createBuilderScripts() {
    cxruntime_file_write(".obj/llvmBuild.sh", "#!/usr/bin/env sh
set -e
llvm-as $1 -o=$2
");
    // -Oz
    // disable -memcpyopt due to https://bugs.llvm.org/show_bug.cgi?id=48599
    cxruntime_file_write(".obj/llvmBuildOpt.sh", "#!/usr/bin/env sh
set -e
opt -O3 $1 -o=$2
");
}
